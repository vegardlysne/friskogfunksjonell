<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vegard Lysne">

<title>Energibalansen - historien om et badekar – Frisk og Funksjonell (arkiv)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Frisk og Funksjonell (arkiv)</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../poster.html"> 
<span class="menu-text">Alle poster</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../naeringsstoffer.html"> 
<span class="menu-text">Næringsstoffene</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../metabolismen.html"> 
<span class="menu-text">Metabolismen</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../fysiologi.html"> 
<span class="menu-text">Fysiologi</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../hormonsystemet.html"> 
<span class="menu-text">Hormoner</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../om.html"> 
<span class="menu-text">Om bloggen</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Energibalansen - historien om et badekar</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Vegard Lysne </p>
            </div>
    </div>
      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Et tema som går igjen og igjen når man diskuterer kosthold er hvordan endringer i kroppsvekten fungerer. Den tradisjonelle tilnærmingen til saken er at det bare handler om energibalansen, og at energi inn - energi ut alltid vil forutsi hvordan kroppsvekten vil utvikle seg over tid. Etter at lavkarbobølgen skylte over landet har en ny oppfatning kommet til live, nemlig ideen om at en kalori ikke er en kalori, og at det er hva vi spiser, og ikke hvor mye, som avgjør hva som skjer med vekten.</p>
<p>I dette innlegget vil jeg bygge litt videre på innlegget mitt om <a href="../artikler/energibalansen.html" title="Energibalansen – hva sier den egentlig?">energibalansen</a>, og rett og slett rive det ned til noe så enkelt som et badekar. Jeg vil anbefale alle å lese den artikkelen først, for å få et bilde av hvor kompleks energibalansen egentlig er.</p>
<section id="er-en-kalori-en-kalori" class="level2">
<h2 class="anchored" data-anchor-id="er-en-kalori-en-kalori">Er en kalori en kalori?</h2>
<p>Kalori er et mål på energi, og en kcal er definert som den energien som trengs for å&nbsp; øke temperaturen på en liter vann med en grad. Per definisjon er derfor en kalori en kalori.</p>
<p>De som mener at en kalori ikke er en kalori snakker ofte om at de energigivende næringsstoffene oppfører seg ulikt i kroppen, noe som er helt riktig. Hva du spiser vil være med å påvirke hor mye du spiser, og det vil også påvirke hvor mye du forbrenner. <a href="http://www.friskogfunksjonell.no/protein/" title="Protein">Protein</a> har andre funksjoner i kroppen enn <a href="http://www.friskogfunksjonell.no/karbohydrater/" title="Karbohydrater">karbohydrater</a> og <a href="http://www.friskogfunksjonell.no/fett/" title="Fett">fett</a>, som hovedsakelig kan regnes som energikilder. <a href="http://www.friskogfunksjonell.no/metthetsfolelsen/" title="Metthetsfølelsen – viktig når du skal velge kosthold">Ulike sammensetninger av næringsstoffene</a> vil også ha ulike effekter på metthetsfølelse og hormonstatus.</p>
<p>Begge sider av saken har altså poenger som er korrekte, men de må brukes i riktig sammenheng. Om du spiser et måltid som inneholder 500 kcal, så er det ikke likegyldig hvilke næringsstoffer måltidet er satt sammen av. Sammensetningen av måltidet vil nemlig påvirke matinntaket senere på dagen, gjennom sine effekter på hormoner og metthetssignaler. Men, hvis du i løpet av en dag har spist 2500 kcal og forbruket har vært 3000 kcal, så vil det være av mindre betydning hvor kaloriene har kommet fra, du er i negativ energibalanse uansett.</p>
</section>
<section id="badekaret" class="level2">
<h2 class="anchored" data-anchor-id="badekaret">Badekaret</h2>
<p>Tenk deg at vi bytter ut menneskekroppen med et badekar. Mengden vann i badekaret, vannstanden, representerer kroppens totale lagre av energi, både fettvevet, muskelvevet og glykogenlagrene. Hver dag fyller vi på mer vann, noe som representerer maten vi spiser. Samtidig vil det også hele tiden renne vann ut gjennom sluken, noe som representerer forbruk av energi. &nbsp;Noe vil også fordampe, eller rett og slett skvulpe utfor kanten. For å opprettholde vannstanden er vi avhengig av å helle oppi like mye vann som det forsvinner over tid. Hvis ikke vil vannstanden øke eller synke.</p>
<p>Dette er utgangspunktet for denne analogien, her følger en forklaring av de ulike delene av energibalansen basert på dette. Som nevnt lenger oppe anbefaler jeg å lese artikkelen om <a href="http://www.friskogfunksjonell.no/energibalansen/" title="Energibalansen – hva sier den egentlig?">energibalansen</a> først.</p>
<p>Energibalanseligningen:</p>
<blockquote class="blockquote">
<p>Energi inn - energi ut = endring i kroppens energilagre</p>
</blockquote>
<section id="energi-inn" class="level4">
<h4 class="anchored" data-anchor-id="energi-inn">Energi inn</h4>
<p>Energi inn tilsvarer i virkeligheten energien vi tilfører kroppen ved å spise og drikke. Når vi snakker om badekaret, er maten representert med vann som tømmes oppi. Nesten all energien vi spiser vil absorberes i tarmsystemet, men noe vil også gå rett gjennom og komme ut på andre siden (helst ikke i badekaret). Du kan tenke deg at vannmuggene holdes med en ustø hånd, og at noe rett og slett bommer og havner på gulvet.</p>
<p>Måltidsstørrelse representeres ved hvor mye du fyller på om gangen, og måltidsfrekvensen representeres ved hvor ofte du fyller på. Det som er av betydning er hvor mye som fylles på <strong>totalt sett over tid</strong>, ikke hvor ofte eller hvor mye du fyller på om gangen.</p>
<blockquote class="blockquote">
<p><strong>Energi inn</strong> = Energien i maten vi spiser - det som ikke absorberes i tarmene</p>
</blockquote>
</section>
<section id="energi-ut" class="level4">
<h4 class="anchored" data-anchor-id="energi-ut">Energi ut</h4>
<p>Energi ut tilsvarer all energi vi bruker. Som jeg skrev i den andre artikkelen så er dette summen av basalforbrenningen (BMR), forbrenning ved aktivitet og den termiske effekten av maten vi spiser (TEF), altså den energien som går med til å fordøye og metabolisere maten. Hvordan passer disse inn i badekaranalogien?</p>
<p>BMR er den energien vi forbrenner hver dag, bare på å holde oss i live. Derfor kan du se for deg at det i et jevnt tempo renner vann ut av sluken hele døgnet.</p>
<p>Hver gang vi beveger oss vil det koste energi, og jo høyere intensiteten/belastningen er, jo mer energi vil det koste. Tenk deg derfor at all bevegelse vil øke mengden vann som presses ned i sluket, og jo mer energikrevende aktiviteten er jo mer vann presses ut.</p>
<p>TEF er den ekstra energien vi bruker i forbindelse med matinntak. Denne varierer for de ulike næringsstoffene, og er høyest for protein (20-30%), etterfulgt av karbohydrat (5-10%) og fett (0-5%). For et sammensatt måltid er det beregnet at ca 10% av energien vil gå med til dette formålet. Se for deg at hver gang du heller vann oppi badekaret fører bevegelsen av vannet til en temperaturøkning, slik at ca 10% av det tilførte vannet fordamper og forsvinner den veien.</p>
<blockquote class="blockquote">
<p><strong>Energi ut</strong> = BMR + TEF + aktivitet</p>
</blockquote>
</section>
</section>
<section id="praktisk-betydning" class="level2">
<h2 class="anchored" data-anchor-id="praktisk-betydning">Praktisk betydning</h2>
<p>Mye kan sies om energibalansen og hvordan den fungerer, men uenigheter handler stort sett om ulike tolkninger eller at man blander mellom fortid og fremtid. Termodynamikkens første læresetning forteller osv at energi verken kan oppstå eller forsvinne, bare overføres fra en form til en annen. Det er nettopp dette som skjer i kroppen vår. Når vi spiser eller drikker, vil den kjemiske energien fra maten kunne overføres til det vi trenger den til, enten det er produksjon av varme eller bevegelse. Om vi tilfører mer energi enn det som brukes, vil vi få en akkumulering av energi, som i kroppen lagres som fettvev. Tilfører vi mindre energi enn vi bruker, vil vi bruke fra kroppens energireserver, og dermed miste fettvev.</p>
<p>Jeg vil også gjøre et ekstra poeng ut av at det er energibalansen over tid som har noe å si, ikke hver dag isolert. De færreste er i balanse fra dag til dag, men over tid har vi mekanismer som vil føre oss i retning balanse. Et tegn på dette er at de aller fleste faktisk er vektstabile, også undervektige og overvektige. Med mindre man stadig prøver å slanke seg med <a href="http://www.friskogfunksjonell.no/midlertidige-losninger/" title="Midlertidige løsninger – midlertidige resultater">midlertidige løsninger</a>, er det få som svinger betydelig opp og ned i vekt.</p>
<p>For å oppnå en vektnedgang må man derfor oppnå en negativ energibalanse over tid, og det er her <a href="http://www.friskogfunksjonell.no/diett-eller-livsstilsendring/" title="Diett eller livsstilsendring?">livsstilsendringer</a> kommer inn i bildet. Midlertidige løsninger vil på grunn av kompensasjonsmekanismer i de fleste tilfeller gi midlertidige resultater, også kjent som jojo-slanking.</p>
<p>Som jeg har prøvd å illustrere i disse to innleggene om energibalansen så er det viktig å ta hensyn til begge sider av ligningen, og ikke bare fokusere på den ene siden. Inntak og forbruk påvirker hverandre, og det er forholdet mellom disse over tid som har en betydning for hvorvidt vannstanden vil synke, stige eller holdes stabil.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>