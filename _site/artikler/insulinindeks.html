<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vegard Lysne">
<meta name="dcterms.date" content="2012-08-07">

<title>Insulinindeks - hva og hvorfor? – Frisk og Funksjonell (arkiv)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Frisk og Funksjonell (arkiv)</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../poster.html"> 
<span class="menu-text">Alle poster</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../naeringsstoffer.html"> 
<span class="menu-text">Næringsstoffene</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../metabolismen.html"> 
<span class="menu-text">Metabolismen</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../fysiologi.html"> 
<span class="menu-text">Fysiologi</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../hormonsystemet.html"> 
<span class="menu-text">Hormoner</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../om.html"> 
<span class="menu-text">Om bloggen</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Insulinindeks - hva og hvorfor?</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Vegard Lysne </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 7, 2012</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><a href="../artikler/hormoner/insulin-glukagon.html" title="Insulin og glukagon">Insulin</a> er et hormon som primært har som oppgave å regulere blodsukkeret og lagre inn energi. Kostholdets innhold av karbohydrater, den glykemiske belastningen, er den faktoren som i størst grad stimulerer produksjonen og utskillelsen av insulin.</p>
<p>I disse lavkarbotider har dette ført til den oppfatningen at mer karbohydrater betyr mer insulin som igjen betyr mer fettlagring. Løsningen på problemet virker både logisk og enkel, spis mindre karbohydrater, produser mindre insulin, og du vil gå ned i vekt. Men er det bare karbohydrater som stimulerer dette hormonet, eller er det flere faktorer som spiller inn?</p>
<p>I 1997 var det en studie [1] som tok for seg akkurat dette, og undersøkte insulinresponsen etter flere ulike matvarer. I 2009 ble det gjennomført en tilsvarende studie [2], men denne gangen på sammensatte måltider.</p>
<section id="hva-er-insulinindeks" class="level2">
<h2 class="anchored" data-anchor-id="hva-er-insulinindeks">Hva er insulinindeks?</h2>
<p>Matvarer som inneholder karbohydrater har en <a href="http://www.friskogfunksjonell.no/mat-og-blodsukker-gi-eller-gb/" title="Mat og blodsukker – GI eller GB?">glykemisk indeks (GI)</a>. Denne beskriver hvor mye blodsukkeret stiger etter inntaket av 50g karbohydrater fra denne matvaren sammenlignet med en referansematvare. Insulinutskillelsen påvirkes hovedsakelig av blodsukkerstigningen, men også flere andre ting er med å påvirker. Forfatterne av den første studien skriver i innledningen:</p>
<blockquote class="blockquote">
<p>However, carbohydrate is not the only stimulus for insulin secretion. Protein-rich foods or the addition of protein to a carbohydrate-rich meal can stimulate a modest rise in insulin secretion without increasing blood glucose concentrations, particularly in subjects with diabetes (20-22).Similarly, adding a large amount of fat to a carbohydrate-rich meal increases insulin secretion even though plasma glucose responses are reduced (23, 24).</p>
<p>Thus, postprandial insulin responses are not always proportional to blood glucose concentrations or to a meal’s total carbohydrate content. Several insulinotropic factors are known to potentiate the stimulatory effect of glucose and mediate postprandial insulin secretion. These include fructose, certain amino acids and fatty acids, and gastrointestinal hormones such as gastric inhibitory peptide, glucagon, and cholecystokinin (25, 26). Thus, protein- and fat-rich foods may induce substantial insulin secretion despite producing relatively small blood glucose responses. We therefore decided that comparing the insulinemic effects of foods on an isoenergetic basis was a logical and practical approach.</p>
</blockquote>
<p>Forfatterne undersøkte derfor hvor stor insulinutskillelsen var etter å ha spist ulike matvarer, og regnet deretter ut en insulinindeks (II). Denne er et mål på hvor mye insulinkonsentrasjonen i blodet stiger etter å ha spist en matvare. Her tas det ikke hensyn til mengde karbohydrater, men energimengden i matvaren. I denne studien er det brukt porsjoner som gir 240 kcal/1000 kJ av de ulike matvarene.</p>
</section>
<section id="hvordan-ble-studien-gjennomført" class="level2">
<h2 class="anchored" data-anchor-id="hvordan-ble-studien-gjennomført">Hvordan ble studien gjennomført?</h2>
<p>I studien ble det totalt undersøkt 38 ulike matvarer, som ble delt inn i 6 ulike matvaregrupper. Alle matvarene ble servert til testpersonene alen, sammen med 2,2 dL vann som drikke.</p>
<p>For hver matvaregruppe ble det valgt ut en gruppe på 11-13 friske personer, og totalt var det 41 testpersoner som deltok i forsøket. Alle testpersonene ble først servert en porsjon hvitt brød, som fungerte som referansematvare. Dette fungerte også som en test for å bekrefte normal glukosetoleranse. Deretter ble de i tilfeldig rekkefølge servert matvarene om morgenen etter 10 timers faste. Etter at matvaren var spist ble det tatt blodprøver hvert kvarter over en periode på to timer der det ble målt blodsukker og insulinkonsentrasjon.</p>
<p>Insulinresponsen ble deretter sammenlignet med insulinresponsen etter hvitt brød for å regne ut II.</p>
</section>
<section id="resultater" class="level2">
<h2 class="anchored" data-anchor-id="resultater">Resultater</h2>
<p>Insulinresponsen etter en porsjon (240 kcal) av de ulike matvarene vises i figur 2. Resultatene er i forhold til hvitt brød, som er satt til 100%.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-824860564.png" class="img-fluid figure-img"></p>
<figcaption>Figur 2 (Holt 1997)</figcaption>
</figure>
</div>
<p>Forfatterne viste at det ikke nødvendigvis var en konsistent sammenheng mellom en matvares effekt på blodsukkeret og den samme matvarens effekt på insulinproduksjonen. Selv om karbohydrater er en viktig faktor for insulinresponsen, så man at enkelte matvaregrupper var mer insulinogene enn blodsukkerresponsen skulle tilsi, mens andre var mindre insulinogene.</p>
<p>Figur 4 viser forholdet mellom insulinresponsen og blodsukkerstigningen for de ulike matvarene.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-2764663908.png" class="img-fluid figure-img"></p>
<figcaption>Figur 4 (Holt 1997)</figcaption>
</figure>
</div>
</section>
<section id="praktisk-betydning-for-diabetikere" class="level2">
<h2 class="anchored" data-anchor-id="praktisk-betydning-for-diabetikere">Praktisk betydning for diabetikere</h2>
<p>I 2009 ble det gjennomført en ny studie [2] som tok for seg dette med insulinindeks. Bakgrunnen for denne studien var å finne en mer nøyaktig måte å regne ut insulinbehovet til de med diabetes. Frem til nå har det vært vanlig å bruke glykemisk belastning (GB = total mengde karbohydrater og GI) for å beregne insulinbehovet, men forfatterne skriver at:</p>
<blockquote class="blockquote">
<p>Together, carbohydrate counting and knowledge of the GI of foods provide the most accurate prediction of likely insulin response (6, 7). However, because GI methodology does not permit the testing of foods with little or no carbohydrate, it cannot provide a guide to the relative insulin response of a large majority of foods in food databases, including high-protein foods such as meat, fish, poultry, eggs, and cheese and high-fat foods such butter and olive oil.</p>
</blockquote>
<p>Med andre ord er forfatterne ute etter en mer presis måte å forutse insulinbehovet etter et sammensatt måltid, slik at man på en enda bedre måte kan kontrollere diabetesen sin. Det blir antatt at insulinbehovet etter et sammensatt måltid best lar seg beregne ved å se på insulinindeksen til de forskjellige matvarene i måltidet, og ikke måltidets totale innhold av karbohydrater og GI.</p>
</section>
<section id="hva-ble-gjort" class="level2">
<h2 class="anchored" data-anchor-id="hva-ble-gjort">Hva ble gjort?</h2>
<p>21 friske, ikke-røykende forsøkspersoner ble etter 10-12 timers faste servert 13 ulikt sammensatte måltider, med likt energiinnhold (480 kcal/2000 kJ). Måltidenes GB ble beregnet utifra karbohydratinnhold og GI, mens II ble beregnet utifra data fra studien omtalt lenger oppe. Hvitt brød ble brukt som referansemåltid.</p>
<p>Etter måltidet ble det tatt blodprøver der man målte insulinkonsentrasjonen i blodet. Denne ble sammenlignet med beregnet insulinbehov beregnet utifra karbohydratinnhold, GB, II, fett-, fiber- og proteininnhold.</p>
</section>
<section id="resultater-1" class="level2">
<h2 class="anchored" data-anchor-id="resultater-1">Resultater</h2>
<p>Både GB (r=0.68) og II (r=0.78) var gode prediktorer for insulinbehovet etter måltid, men II korrelerte aller best. Karbohydratinnholdet var ikke en spesielt god prediktor for insulinbehov etter et måltid. Fett viste seg å ha en omvendt korrelasjon, mens protein og fiber ikke viste seg å ha noen konsistent sammenheng i det hele tatt.</p>
<p>Sammenhengen mellom de ulike prediktorene og faktisk insulinutskillelse vises i figurene under:</p>
<p><img src="http://www.friskogfunksjonell.no/wp-content/uploads/2012/08/Insulinindeks-2-A-F.png" title="Insulinindeks 2 A-F" class="img-fluid" alt=""> Figur 2 A-F (Bao 2009)</p>
</section>
<section id="konklusjoner" class="level2">
<h2 class="anchored" data-anchor-id="konklusjoner">Konklusjoner</h2>
<p>Både GB og II ser ut til å være gode alternativer for å beregne insulinbehovet etter et måltid, men ut ifra dataene ser det ut som om II er den mest nøyaktige prediktoren, siden den også gjør det mulig å ta hensyn til måltidets innhold av andre næringsstoffer enn karbohydrater.</p>
<p>I diskusjonen skriver forfatterne at konseptet med II også kan være nyttig for den friske befolkningen, siden økt insulinutskillelse er assosiert med økt risiko for diabetes, overvekt og generelt metabolsk syndrom. Likevel må det også tas med i betraktningen at det var få forsøkspersoner, og at disse var friske og slanke. Det er derfor sannsynlig at resultatene ikke kan overføres direkte til mennesker som ikke går inn under denne definisjonen.</p>
<p>Det er likevel ingen tvil om at det å kalkulere insulinbehovet utifra total mengde karbohydrater er en svært upresis metode, da måltider med likt innhold av karbohydrater kan gi vidt forskjellig insulinrespons. Det er derfor nærliggende å tro at II i fremtiden vil overta som prediktor i behandlingen av type 1 diabetes. Forfatterne skriver:</p>
<blockquote class="blockquote">
<p>In summary, the relative insulin demand evoked by mixed meals consumed by lean young healthy subjects is best predicted by a physiologic index based on integrating insulin responses to isoenergetic portions of single foods. In the context of composite meals of similar energy value but varying macronutrient content, carbohydrate counting had limited value.</p>
</blockquote>
<p>Foreløpig trengs det mer forskning på dette feltet, og den må også nødvendigvis gjøres på relevante populasjoner og ikke bare på friske. Kanskje vil vi få en endring i rådene om hvordan man bør spise om man har diabetes, <a href="http://www.friskogfunksjonell.no/hvordan-bor-en-diabetiker-spise/" title="Hvordan bør en diabetiker spise?">noe forskningen allerede tyder på</a>.</p>
<section id="referanser" class="level4">
<h4 class="anchored" data-anchor-id="referanser">Referanser</h4>
<p>1. Holt SH, Miller JC, Petocz P: <strong>An insulin index of foods: the insulin demand generated by 1000-kJ portions of common foods</strong>. <em>Am J Clin Nutr</em> 1997, <strong>66</strong>(5):1264-1276.</p>
<p>2. Bao J, de Jong V, Atkinson F, Petocz P, Brand-Miller JC: <strong>Food insulin index: physiologic basis for predicting insulin demand evoked by composite meals</strong>. <em>Am J Clin Nutr</em> 2009, <strong>90</strong>(4):986-992.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>