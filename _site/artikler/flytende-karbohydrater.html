<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vegard Lysne">
<meta name="dcterms.date" content="2011-12-01">

<title>Bør du begrense inntaket av flytende karbohydrater? – Frisk og Funksjonell (arkiv)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Frisk og Funksjonell (arkiv)</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../poster.html"> 
<span class="menu-text">Alle poster</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../naeringsstoffer.html"> 
<span class="menu-text">Næringsstoffene</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../metabolismen.html"> 
<span class="menu-text">Metabolismen</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../fysiologi.html"> 
<span class="menu-text">Fysiologi</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../hormonsystemet.html"> 
<span class="menu-text">Hormoner</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../kildekritikk.html"> 
<span class="menu-text">Kildekritikk</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../kosthold-institusjoner.html"> 
<span class="menu-text">Kosthold i helseinstitusjoner</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../om.html"> 
<span class="menu-text">Om bloggen</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Bør du begrense inntaket av flytende karbohydrater?</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">kosthold</div>
                <div class="quarto-category">helse</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Vegard Lysne </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 1, 2011</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Forbruket av sukkerholdige drikkevarer som brus og fruktjuice har økt voldsomt de siste 50 årene. Kan inntaket av karbohydrater i flytende form være en av de viktigste årsakene til den økte forekomsten av overvekt, fedme og livsstilssykdommer? Det er etterhvert gjort en del studier på effektene av karbohydrater i hhv flytende og fast form, og her skal vi se litt på hva noen av disse har konkludert med.</p>
<section id="metter-mindre" class="level1">
<h1>Metter mindre</h1>
<p>Det er foreslått at <a href="http://www.friskogfunksjonell.no/karbohydrater/" title="Karbohydrater">karbohydrater</a> i flytende form metter dårligere enn samme energimengde i fast form. <strong>Et høyt inntak av flytende karbohydrater i form av brus, saft og fruktjuice kan derfor gjøre at du spiser mer, og derfor legger på deg.</strong> Vi har sett en kraftig økning i forbruket av disse drikkevarene, og rapporten «Utviklingen i norsk kosthold 2010» kan fortelle oss at det årlige inntaket av sukret brus har økt fra 9 til 60 liter per innbygger siden 1950. Siden 1977 har vi også hatt en firedobling i forbruket av fruktjuice, og en dobling i inntaket av saft og syltetøy.</p>
<p>Det må understrekes at det er noen svakheter med mange av studiene som har undersøkt denne sammenhengen. I en artikkel fra 2003 hevdes det at resultatene til nå har vært inkonklusive [1], noe som også nevnes i en annen studie fra 2007 [2]. <strong>Effekten av metthet måles ofte i hvor mye testpersonene spiser i det påfølgende måltidet.</strong> Det påpekes at de studiene som har konkludert med at flytende karbohydrater metter dårligere, ofte har hatt en lengre periode mellom disse måltidene, mens studier som bruker en kortere periode ofte har vist motsatte resultater. Her er det tydelig at det er flere ting som spiller inn på mettheten.</p>
<p>I en studie fra 2011 undersøkte forfatterne om dette kunne henge sammen med effektene på blodsukkeret og insulinutskillelsen, men forsøket viste at det her ikke var noen forskjeller mellom flytende eller faste karbohydratkilder [3]. Likevel mettet de faste karbohydratkildene mer enn de flytende gjorde.</p>
<p>En studie fra 2003 så på sammenhengen mellom totalvolum, energimengde og metthet, og konkluderte med at <strong>volumet på drikken man inntok hadde en større innvirkning på mettheten enn energimengden</strong>, og til og med en dobling av energiinnholdet på samme volum endret ikke disse resultatene [4].</p>
<p>I en studie fra 2007 sammenlignet forfatterne effekten av en måltidserstatter i flytende eller fast form, der energiinnholdet og sammensetningen av næringsstoffer var identisk. Her viste det seg at <strong>måltidet i fast form gav en mye høyere metthetsfølelse</strong>, og forfatterne konkluderte med at de to ulike produktene ikke kunne sees på som likeverdige alternativer [5].</p>
<p>En siste studie fra 2011 konkluderer med at karbohydrater i flytende form metter mindre enn karbohydrater i fast form [6]. Her så forfatterne også på hvordan flytende karbohydrater påvirker det totale energiinntaket i løpet av dagen, og konkluderte med at selv om det var en viss kompensasjon (man spiste mindre senere på dagen), så var ikke denne fullstendig, og <strong>totalt sett økte energiinntaket</strong>.</p>
</section>
<section id="drikkevarer-assosiert-med-vektoppgang" class="level1">
<h1>Drikkevarer assosiert med vektoppgang</h1>
<p>En analyse fra 2011 viste at alle drikkevarer bortsett fra melk var assosiert med vektoppgang [7]. Fruktjuice hadde mindre sammenheng enn brus, men det forklares med at man vanligvis drikker brus i større mengder. Forfatterne skriver at:</p>
<blockquote class="blockquote">
<p><em>Consumption of 100%-fruit juice was associated with weight gains of smaller magnitude, possibly because these beverages may be consumed in smaller servings than are sugarsweetened beverages or in different patterns (i.e., single rather than multiple servings).</em></p>
</blockquote>
<p>Og deretter at:</p>
<blockquote class="blockquote">
<p><em>Overall, our analysis showed that changes in the consumption of all liquids except milk were positively associated with weight gain;our findings for high-carbohydrate beverages were consistent with those for refined carbohydrates and starches consumed in foods.</em></p>
</blockquote>
<p>Her er en figur fra analysen:</p>
<p><img src="images/clipboard-2976871205.png" class="img-fluid"></p>
</section>
<section id="hvor-fort-spiserdrikker-du" class="level1">
<h1>Hvor fort spiser/drikker du?</h1>
<p>I en studie fra 2011 foreslår forfatterne at grunnen til at flytende karbohydrater metter dårligere er at hastigheten på inntaket er høy per energimengde [8]. Med dette menes det at det går fortere å drikke en viss energimengde enn å spise den samme energien. De skriver at:</p>
<blockquote class="blockquote">
<p><em>This idea fits with the concept of the taste system as a nutrient-sensing system that informs the brain and the gastro-intestinal system about what is coming into our body. With liquids, this system is bypassed. Slower eating may help the human body to associate the sensory signals from food with their metabolic consequences. Foods that are eaten quickly may impair this association, and may therefore lead to overconsumption of energy, and ultimately to weight gain.</em></p>
</blockquote>
<p><strong>Det kan synes som om at jo lengre maten er i munnen, jo sterkere stimuleres metthetsfølelsen.</strong> Dette kan forklare hvorfor matinntaket blir lavere dersom man spiser sakte. Dette forklares med at seonsorer i munnen sender signaler til hjernen om hvilken næring som er på vei. Når energien inntas i flytende form får ikke dette systemet fungert som det skal, noe som fører til at det totale energiinntaket øker. Suppe har vist seg å gi god metthet og gir en reduksjon i det totale energiinntaket, noe som passer fint med teorien om hastigheten på inntaket, som er mye lavere for suppe enn for energiholdige drikkevarer.</p>
</section>
<section id="konklusjoner" class="level1">
<h1>Konklusjoner</h1>
<p>Selv om studiene vi har per i dag ikke er nok til å gi en endelig konklusjon, er det grunn til å anta at inntaket av karbohydrater i flytende form bør begrenses, <strong>spesielt om du vil ned i vekt</strong>. Flere studier har vist at inntak av flytende karbohydrater øker det totale energiinntaket, siden man ikke kompenserer fullstendig for den ekstra energien. Dette passer fint med statistikken over inntak av disse drikkevarene og økningen i forekomsten av overvekt og fedme.</p>
<p>En teori for hvorfor flytende karbohydrater metter dårligere enn karbohydrater i fast form handler om hvor lang tid man bruker på å få i seg en viss mengde. <strong>Generelt går det raskere å drikke denne energimengden enn å spise den</strong>, noe som også støtter opp om teorien om at å spise sakte øker metthetsfølelsen.</p>
<p>I våre <a href="http://www.friskogfunksjonell.no/vare-rad-for-bedre-helse/" title="Våre råd for bedre helse">råd for bedre helse</a> lyder et av rådene: Vær forsiktig med flytende energi.</p>
<p>Alle er enige i at sukker ikke er bra for oss. En halv liter brus inneholder ca 50g sukker, og fruktjuice inneholder tilsvarende mengder.<br>
Innholdet av vitaminer og mineraler er også lavt eller fraværende i flytende karbohydratkilder. Om du spiser frukten i stedet for å drikke fruktjuice får du i deg betydelig mer av disse næringsstoffene, i tillegg til en del fiber som reduserer de negative effektene av sukkeret.</p>
<p>Denne <a href="http://www.youtube.com/watch?v=yKZ2ZqBYlrI">videoen</a> illustrerer på en fin måte hvor mye sukker som finnes i en boks brus:</p>
<p><strong>Referanser:</strong></p>
<ol class="incremental" type="1">
<li><p>Almiron-Roig E, Chen Y, Drewnowski A: <strong>Liquid calories and the failure of satiety: how good is the evidence?</strong> Obes Rev 2003, 4(4):201-212.</p></li>
<li><p>Drewnowski A, Bellisle F: <strong>Liquid calories, sugar, and body weight</strong>. Am J Clin Nutr 2007, 85(3):651-661.</p></li>
<li><p>Ranawana V, Henry CJ: <strong>Liquid and solid carbohydrate foods: comparative effects on glycemic and insulin responses, and satiety</strong>. Int J Food Sci Nutr 2011, 62(1):71-81.</p></li>
<li><p>Bell EA, Roe LS, Rolls BJ: <strong>Sensory-specific satiety is affected more by volume than by energy content of a liquid food</strong>. Physiol Behav 2003, 78(4-5):593-600.</p></li>
<li><p>Tieken SM, Leidy HJ, Stull AJ, Mattes RD, Schuster RA, Campbell WW: <strong>Effects of solid versus liquid meal-replacement products of similar energy content on hunger, satiety, and appetite-regulating hormones in older adults</strong>. Horm Metab Res 2007, 39(5):389-394.</p></li>
<li><p>Pan A, Hu FB: <strong>Effects of carbohydrates on satiety: differences between liquid and solid food</strong>. Curr Opin Clin Nutr Metab Care 2011, 14(4):385-390.</p></li>
<li><p>Mozaffarian D, Hao T, Rimm EB, Willett WC, Hu FB: <strong>Changes in diet and lifestyle and long-term weight gain in women and men</strong>. N Engl J Med 2011, 364(25):2392-2404.</p></li>
<li><p>de Graaf C: <strong>Why liquid energy results in overconsumption</strong>. Proc Nutr Soc 2011, 70(2):162-170.</p></li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>